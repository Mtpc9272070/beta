<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lobby de Partidas - ADUWEB</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <style>
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        .group-card {
            @apply bg-white p-4 rounded-xl shadow-md border-2 border-gray-200 transition duration-200;
        }
        .group-card.my-group {
            @apply ring-4 ring-blue-300 border-blue-500;
        }
        .join-group-btn {
            @apply w-full mt-2 bg-green-500 text-white font-semibold py-1 px-3 rounded-lg hover:bg-green-600 transition text-sm;
        }
        .join-group-btn:disabled {
            @apply bg-gray-400 cursor-not-allowed;
        }
        .template-card {
            @apply relative p-4 border-2 border-gray-300 rounded-xl cursor-pointer transition-all duration-200 text-center bg-white shadow-sm;
        }
        .template-card.selected {
            @apply border-blue-500 bg-blue-50 shadow-lg ring-4 ring-blue-200;
        }
        /* NUEVO: Estilo para el icono y texto cuando la tarjeta está seleccionada */
        .template-card.selected .template-icon { @apply text-blue-600; }
        .template-card.selected .template-name { @apply text-blue-800; }
        /* NUEVO: Estilo para la insignia de numeración */
        .selection-badge {
            position: absolute;
            top: -12px;
            right: -12px;
            width: 28px;
            height: 28px;
            background-color: #2563eb; /* blue-600 */
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
            transform: scale(0);
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .template-card.selected .selection-badge {
            transform: scale(1);
        }
        .leader-option:hover { @apply bg-blue-100; }

        .card-content {
            @apply bg-blue-100;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <!-- NUEVO HEADER ESTANDARIZADO -->
    <header class="bg-white py-4 px-6 shadow-md sticky top-0 z-20 border-b">
        <div class="max-w-7xl mx-auto flex justify-between items-center">
            <div class="flex items-center gap-4">
                <span class="text-2xl font-extrabold text-green-700">ADUWEB</span>
                <span class="text-sm font-light text-gray-500 hidden sm:block">| Lobby de Partidas</span>
            </div>
        </div>
    </header>

    <!-- Elementos de Audio -->
    <audio id="soundClick" src="/beta/click.mp3" preload="auto"></audio>

    <main class="max-w-4xl w-full p-6 md:p-10 mx-auto animate-fade-in">
        <h1 id="main-title" class="text-3xl font-extrabold text-gray-900 border-b pb-4 mb-8 flex items-center gap-3">
            <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-600"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
            Lobby de Partidas
        </h1>

        <!-- Pantalla de Creación/Unión -->
        <div id="lobby-controls">
            <div class="bg-white p-6 rounded-xl shadow-lg mb-8">
                <h2 class="text-xl font-bold text-gray-700 mb-4">Unirse a una Partida Existente</h2>
                <div class="flex space-x-4">
                    <input type="text" id="matchIdInput" placeholder="ID de la Partida (Ej: PART-ABCD)" class="flex-grow p-3 border-2 border-gray-300 rounded-lg">
                    <button onclick="joinMatchFromInput();" class="p-3 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 transition shadow-md">
                        Unirse
                    </button>
                </div>
            </div>

            <!-- NUEVO: Plantillas Destacadas -->
            <div class="bg-white p-6 rounded-xl shadow-lg mb-8">
                <h2 class="text-xl font-bold text-gray-700 mb-4">🔥 Plantillas Destacadas (Mejor Calificadas)</h2>
                <div id="featured-templates-container" class="grid grid-cols-1 md:grid-cols-3 gap-4"></div>
            </div>

            <!-- MODIFICADO: Formulario de creación con nuevas opciones -->
            <div class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-xl font-bold text-gray-700 mb-4">Crear Nueva Partida</h2>
                <div class="space-y-4">
                    <div>
                        <label for="matchName" class="block text-sm font-medium text-gray-700">Nombre de la Partida</label>
                        <input type="text" id="matchName" placeholder="Ej: Torneo Final Semestre 1" class="w-full p-2 border border-gray-300 rounded-lg mt-1" value="Partida de Prueba">
                    </div>

                    <!-- NUEVO: Selección de tipo de sala -->
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Tipo de Sala</label>
                        <div class="flex gap-4 mt-1">
                            <label><input type="radio" name="matchType" value="grupal" checked onchange="toggleGroupOptions()"> Grupal</label>
                            <label><input type="radio" name="matchType" value="individual" onchange="toggleGroupOptions()"> Individual</label>
                        </div>
                    </div>

                    <!-- NUEVO: Selección de plantilla con tarjetas -->
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Plantilla de Juego</label>
                        <p id="template-selection-hint" class="text-xs text-gray-500 mb-2">Selecciona las plantillas para la competición. El número de juegos debe coincidir con el número de jugadores por grupo.</p>
                        <div id="template-selection-container" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3">
                            <!-- Las tarjetas se generan dinámicamente -->
                        </div>
                    </div>

                    <!-- MODIFICADO: Opciones de grupo (se pueden ocultar) -->
                    <div id="group-options" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="numGroups" class="block text-sm font-medium text-gray-700">Número de Grupos (1-5)</label>
                            <input type="number" id="numGroups" value="2" min="1" max="5" class="w-full p-2 border border-gray-300 rounded-lg mt-1">
                        </div>
                        <div>
                            <label for="playersPerGroup" class="block text-sm font-medium text-gray-700">Jugadores por Grupo (1-5)</label>
                            <input type="number" id="playersPerGroup" value="5" min="1" max="5" class="w-full p-2 border border-gray-300 rounded-lg mt-1">
                        </div>
                    </div>

                    <button id="createMatchBtn" onclick="createMatch()" class="w-full p-3 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition shadow-md">
                        Crear Partida y Abrir Lobby
                    </button>
                </div>
            </div>
        </div>

        <!-- Pantalla de Lobby de Partida (Oculta) -->
        <div id="match-lobby" class="hidden space-y-6 bg-gray-50 p-6 rounded-xl border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 flex justify-between items-center">
                <span>Lobby: <span id="currentMatchName" class="text-blue-600"></span></span>
                <button onclick="copyInviteLink()" class="text-sm bg-yellow-400 text-yellow-900 font-semibold px-3 py-1 rounded-full hover:bg-yellow-500 transition">
                    ID: <span id="currentMatchId"></span> (Copiar Enlace)
                </button>
            </h2>

            <!-- MODIFICADO: Controles del lobby con botón de invitar y listo -->
            <div class="flex flex-wrap justify-between items-center gap-4">
                <div class="flex gap-2">
                    <button onclick="leaveMatch();" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg text-sm font-semibold transition shadow-md flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>
                    Salir del Lobby
                    </button>
                    <button onclick="openInviteModal();" class="bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded-lg text-sm font-semibold transition shadow-md flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line></svg>
                        Invitar
                    </button>
                </div>
                <button id="player-action-button" class="p-3 bg-indigo-600 text-white font-bold rounded-lg transition shadow-md">
                    Iniciar Partida para Todos
                </button>
            </div>

            <h3 class="text-xl font-bold text-gray-700 pt-4 border-t">Grupos en la Partida</h3>
            <div id="groups-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <!-- Las tarjetas de grupo se insertarán aquí -->
            </div>
        </div>
    </main>

    <!-- NUEVO: Modal de Invitación (Oculto por defecto) -->
    <div id="inviteModal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-xl max-w-md w-full shadow-2xl">
            <div class="p-4 border-b flex justify-between items-center">
                <h3 class="text-xl font-bold text-gray-800">Invitar Jugadores</h3>
                <button onclick="playSound('soundClick'); closeInviteModal();" class="text-gray-500 hover:text-red-600">&times;</button>
            </div>
            <div class="p-4">
                <input type="text" id="userSearchInput" onkeyup="filterUserList()" placeholder="Buscar jugador por nombre..." class="w-full p-2 border rounded-lg mb-3">
                <div id="userListContainer" class="max-h-64 overflow-y-auto space-y-2">
                    <!-- La lista de usuarios se cargará aquí -->
                    <p class="text-center text-gray-500">Cargando usuarios...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- NUEVO: Modal para Pasar Liderazgo -->
    <div id="passLeaderModal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-xl max-w-md w-full shadow-2xl">
            <div class="p-4 border-b flex justify-between items-center">
                <h3 class="text-xl font-bold text-gray-800">Pasar Liderazgo</h3>
                <button onclick="playSound('soundClick'); closePassLeaderModal();" class="text-gray-500 hover:text-red-600">&times;</button>
            </div>
            <div class="p-4">
                <p class="text-gray-600 mb-4">Selecciona a qué jugador quieres transferir el liderazgo.</p>
                <div id="newLeaderListContainer" class="max-h-64 overflow-y-auto space-y-2">
                    <!-- La lista de jugadores para pasar liderazgo se cargará aquí -->
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.11/firebase-app.js"; // Firebase App (core)
        import { getDatabase, ref, set, get, update, remove, onValue, off, push } from "https://www.gstatic.com/firebasejs/9.6.11/firebase-database.js"; // Firebase Realtime Database
        import { firebaseConfig } from "./config.js"; // Importar configuración centralizada
        import { playSound } from "./utils.js"; // Import the common playSound function

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // 🔑 VARIABLES CLAVE
        let currentMatchId = null;
        let currentPlayerKey = null;
        let playerName = null;
        let isRoomLeader = false;
        let matchListener = null; 
        let currentMatchData = {}; // Variable para almacenar el estado actual de la partida
        let allUsers = {}; // Caché de todos los usuarios para el modal de invitación

        // --- DATOS DE PLANTILLAS (MOVIDO AFUERA PARA SER GLOBAL) ---
        const TEMPLATE_DATA = [
            { id: 'process_hierarchy', name: 'La Merca', icon: '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>' },
            { id: 'time_trial', name: 'Contra Reloj', icon: '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>' },
            { id: 'incoterm_riddle', name: 'Adivinanza', icon: '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>' },
            { id: 'transport_race', name: 'Carrera', icon: '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2L18 6l-4 4h10v4H14l4 4-4 4H2v-4h10l-4-4 4-4H2V2h12z"></path></svg>' },
            { id: 'q_and_a', name: 'Cuestionario', icon: '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>' },
            { id: 'document_finder', name: 'Buscador Docs', icon: '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><circle cx="10.5" cy="13.5" r="2.5"></circle><line x1="12.5" y1="15.5" x2="15" y2="18"></line></svg>' },
            { id: 'merch_identifier', name: 'Identificador', icon: '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg>' },
            { id: 'cargo_carousel', name: 'Carrusel Carga', icon: '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12h20M2 6h20M2 18h20"></path></svg>' },
            { id: 'role_puzzle', name: 'Puzzle Cargos', icon: '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 10V4.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5V10H4.5a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5H10v5.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5V14h5.5a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5H14z"></path></svg>' },
            { id: 'customs_duel', name: 'Duelo Aduanero', icon: '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.79 7.85a.5.5 0 0 0-.58 0l-5.66 5.66a.5.5 0 0 0 0 .71l5.66 5.66a.5.5 0 0 0 .71 0l5.66-5.66a.5.5 0 0 0 0-.71z"></path><path d="M18 22V12l-6-6-6 6v10"></path><path d="M14 2v6"></path></svg>' }
        ];


        // ----------------------------------------------------------------------
        // 🔄 FUNCIONES DE FIREBASE Y TIEMPO REAL
        // ----------------------------------------------------------------------

        /**
         * 🟢 Inicia la escucha en tiempo real de la partida actual.
         */
        function startListening(matchId) {
            if (matchListener) {
                off(matchListener);
            }
            
            const matchRef = ref(db, `matches/${matchId}`);
            
            matchListener = onValue(matchRef, (snapshot) => {
                const matchData = snapshot.val();
                if (!matchData) {
                    if (currentMatchId === matchId) {
                         Swal.fire('Atención', 'La partida ha sido cerrada por el líder.', 'info');
                         leaveGame(false); 
                    }
                    return;
                }

                // Guardar el estado actual de la sala para usarlo en otras funciones
                currentMatchData = matchData;

                renderMatchState(matchData);
                
                // 🚀 Lógica de inicio de juego
                if (matchData.status === 'IN_PROGRESS') {
                    const playerGroup = Object.values(matchData.groups || {}).find(g => g.players && g.players[currentPlayerKey]);
                    if (!playerGroup) return; 
                    const player = playerGroup.players[currentPlayerKey];
                    if (!player || !player.assigned_game) return; // Si el jugador no tiene un juego asignado, no hace nada.

                    // CORRECCIÓN: Usar el juego asignado al jugador, no una plantilla global.
                    const gameUrl = getGameUrlFromTemplate(player.assigned_game);
                    // Asignar rol si es una partida de "La Merca"
                    if (player.assigned_game === 'process_hierarchy') {
                        assignRolesToGroup(matchId, playerGroup.id);
                    }

                    Swal.fire({ // Mover la redirección aquí
                        title: '¡Juego Iniciado!',
                        text: `Redirigiendo a la partida...`,
                        icon: 'success',
                        timer: 1500,
                        showConfirmButton: false,
                        didClose: () => {
                            // MODIFICADO: Ahora pasamos más datos al juego
                            window.location.href = `${gameUrl}?matchId=${currentMatchId}&groupId=${playerGroup.id}&playerKey=${currentPlayerKey}&gameId=${player.assigned_game}`;
                        }
                    });
                    if (matchListener) {
                        matchListener(); // CORRECCIÓN: Llamar a la función de desuscripción
                    }
                }
            });
        }

        /**
         * 🎨 Renderiza el estado de la partida, grupos y jugadores.
         */
        function renderMatchState(matchData) {
            document.getElementById('currentMatchName').textContent = matchData.config.name;
            document.getElementById('currentMatchId').textContent = matchData.id;

            const groupsContainer = document.getElementById('groups-container');
            groupsContainer.innerHTML = '';

            const groups = matchData.groups || {};
            const groupIds = Object.keys(groups);
            let totalPlayers = 0;
            let allPlayersReady = true;
            let allGroupsReady = true;

            groupIds.forEach(groupId => {
                const group = groups[groupId];
                const players = group.players || {};
                const playerCount = Object.keys(players).length;
                totalPlayers += playerCount;

                const isMyGroup = players[currentPlayerKey];
                const maxPlayersPerGroup = matchData.config.players_per_group;
                const isFull = playerCount >= maxPlayersPerGroup;

                // Lógica de estado "listo"
                let readyPlayersCount = 0;
                let playersHtml = '';
                // CORRECCIÓN: Añadir una guarda para evitar errores si un jugador es nulo o indefinido.
                Object.values(players || {}).filter(p => p && p.name).forEach(p => { // Reforzamos la guarda
                    if (p && p.name) { // Doble verificación para seguridad
                        const readyIcon = p.ready ? '✅' : '⌛';
                        if (p.ready) readyPlayersCount++;
                        playersHtml += `<li class="text-sm ${p.key === currentPlayerKey ? 'font-bold text-blue-700' : ''}">${readyIcon} ${p.name}</li>`;
                    }
                });

                const isGroupReady = readyPlayersCount === playerCount && playerCount > 0;
                if (!isGroupReady) allGroupsReady = false;

                const groupCard = document.createElement('div');
                groupCard.className = `group-card ${isMyGroup ? 'my-group' : ''}`;
                groupCard.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            <h4 class="font-bold text-lg text-gray-800">${group.name}</h4>
                            <p class="text-xs text-gray-500 mb-2">(${playerCount} / ${maxPlayersPerGroup} jugadores)</p>
                        </div>
                        <span class="text-xs font-bold px-2 py-1 rounded-full ${isGroupReady ? 'bg-green-200 text-green-800' : 'bg-yellow-200 text-yellow-800'}">
                            ${isGroupReady ? 'LISTO' : 'ESPERANDO'}
                        </span>
                    </div>
                    <ul class="space-y-1 min-h-[80px]">${playersHtml}</ul>
                    <button onclick="joinGroup('${groupId}')" class="join-group-btn" ${isFull || isMyGroup ? 'disabled' : ''}>
                        ${isMyGroup ? 'Estás Aquí' : (isFull ? 'Grupo Lleno' : 'Unirse a Grupo')}
                    </button>
                `;
                groupsContainer.appendChild(groupCard);

                // Verificar si todos los jugadores están listos (para modo individual)
                if (Object.values(players).some(p => !p.ready)) {
                    allPlayersReady = false;
                }
            });

            // Actualizar estado del botón de acción principal
            const actionButton = document.getElementById('player-action-button');
            if (isRoomLeader) {
                // CORRECCIÓN: El líder puede iniciar si todos los OTROS jugadores están listos.
                const allOtherPlayers = Object.values(matchData.groups || {}).flatMap(g => Object.values(g.players || {})).filter(p => p.key !== currentPlayerKey);
                const readyPlayersCount = allOtherPlayers.filter(p => p.ready).length;
                const allOthersReady = readyPlayersCount === allOtherPlayers.length && allOtherPlayers.length > 0;

                actionButton.onclick = startMatch;
                actionButton.disabled = !allOthersReady;

                if (allOthersReady) {
                    actionButton.textContent = 'Iniciar Partida para Todos';
                    actionButton.classList.remove('opacity-50', 'cursor-not-allowed');
                } else {
                    const waitingFor = allOtherPlayers.length - readyPlayersCount;
                    actionButton.textContent = `Esperando a ${waitingFor} jugador(es)...`;
                    actionButton.classList.add('opacity-50', 'cursor-not-allowed');
                }
            } else {
                const myPlayer = Object.values(matchData.groups || {}).flatMap(g => Object.values(g.players || {})).find(p => p.key === currentPlayerKey);
                if (myPlayer && myPlayer.ready) {
                    actionButton.textContent = 'Esperando...';
                    actionButton.disabled = true;
                    actionButton.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    actionButton.textContent = '¡Estoy Listo!';
                    actionButton.onclick = setPlayerReady;
                    actionButton.disabled = false;
                    actionButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }
        }

        /**
         * NUEVO: Establece el estado "listo" del jugador.
         */
        async function setPlayerReady() {
            playSound('soundClick');
            const playerGroupEntry = Object.entries(currentMatchData.groups || {}).find(([gId, g]) => g.players && g.players[currentPlayerKey]);
            if (playerGroupEntry) {
                const groupId = playerGroupEntry[0];
                const playerReadyRef = ref(db, `matches/${currentMatchId}/groups/${groupId}/players/${currentPlayerKey}/ready`);
                await set(playerReadyRef, true);
            }
        }

        function getGameUrlFromTemplate(templateId) {
            switch (templateId) {
                case 'process_hierarchy': return 'lamerca.html';
                case 'time_trial': return 'carrera_reloj.html';
                case 'incoterm_riddle': return 'campo_minado.html';
                case 'transport_race': return 'carrera_transporte.html';
                case 'q_and_a': return 'icogame.html'; // NUEVO JUEGO AÑADIDO
                case 'document_finder': return 'buscador_documentos.html'; // NUEVO JUEGO
                case 'merch_identifier': return 'identificador_mercancia.html'; // NUEVO JUEGO
                case 'cargo_carousel': return 'carrusel_carga.html'; // NUEVO JUEGO
                case 'role_puzzle': return 'rompecabezas_cargos.html'; // NUEVO JUEGO
                case 'customs_duel': return 'duelo_aduanero.html'; // NUEVO JUEGO AÑADIDO
                default: return 'index.html'; // Fallback
            }
        }

        /**
         * 🚪 MODIFICADO: Gestiona la salida de la sala.
         * Si es el líder, le da opciones. Si es un jugador normal, simplemente sale.
         */
        async function leaveMatch(notifyFirebase = true) {
            playSound('soundClick');
            if (isRoomLeader) {
                // Si es el líder, mostrar modal con opciones
                const { value: action } = await Swal.fire({
                    title: 'Eres el líder de la sala',
                    text: '¿Qué deseas hacer?',
                    icon: 'question',
                    showCancelButton: true,
                    showDenyButton: true,
                    confirmButtonText: 'Pasar Liderazgo',
                    denyButtonText: 'Eliminar Sala',
                    cancelButtonText: 'Cancelar',
                    confirmButtonColor: '#3b82f6', // blue-500
                    denyButtonColor: '#ef4444',    // red-500
                });

                if (action === true) { // El usuario hizo clic en "Pasar Liderazgo"
                    openPassLeaderModal();
                } else if (action === false) { // El usuario hizo clic en "Eliminar Sala"
                    await deleteRoom();
                }
                // Si es 'cancel', no se hace nada.

            } else {
                // Si no es el líder, simplemente sale de la sala.
                await exitAsPlayer(notifyFirebase);
            }
        }

        /**
         * 🚪 Lógica para que un jugador normal salga de la sala.
         */
        async function exitAsPlayer(notifyFirebase = true) {
            if (matchListener) {
                matchListener(); // CORRECCIÓN: Llamar a la función de desuscripción
                matchListener = null;
            }

            if (currentMatchId && currentPlayerKey && notifyFirebase && currentMatchData.groups) {
                const playerGroup = Object.entries(currentMatchData.groups).find(([groupId, group]) => group.players && group.players[currentPlayerKey]);
                if (playerGroup) {
                    const groupId = playerGroup[0];
                    const playerRef = ref(db, `matches/${currentMatchId}/groups/${groupId}/players/${currentPlayerKey}`);
                    // OPTIMIZACIÓN: Limpiar la partida activa del perfil del usuario.
                    const userActiveMatchRef = ref(db, `usuarios/${currentPlayerKey}/activeMatch`);
                    await set(userActiveMatchRef, null);

                    await remove(playerRef);
                }
            }

            // Redirigir siempre al dashboard principal
            window.location.href = 'index.html'; 
        }

        /**
         * 🗑️ Lógica para que el líder elimine la sala para todos.
         */
        async function deleteRoom() {
            Swal.fire({
                title: 'Eliminando Sala...',
                text: 'Todos los jugadores serán expulsados.',
                icon: 'warning',
                showConfirmButton: false,
                timer: 2000
            });

            if (matchListener) {
                matchListener(); // CORRECCIÓN: Llamar a la función de desuscripción
                matchListener = null;
            }

            if (currentMatchId) {
                const matchRef = ref(db, `matches/${currentMatchId}`);
                // OPTIMIZACIÓN: Limpiar la partida activa de todos los jugadores de la sala.
                const updates = {};
                Object.values(currentMatchData.groups || {}).forEach(g => {
                    Object.keys(g.players || {}).forEach(pKey => updates[`usuarios/${pKey}/activeMatch`] = null);
                });
                await update(ref(db), updates);

                await remove(matchRef);
            }

            window.location.href = 'index.html';
        }

        /**
         * 🚀 Inicia el juego actualizando el estado de la sala a 'EN_CURSO'.
         */
        function startMatch() {
            // REFACTORIZADO: Lógica de asignación de juegos
            playSound('soundClick');
            if (!isRoomLeader) return;

            const updates = {};
            const matchConfig = currentMatchData.config;
            const templates = matchConfig.game_templates;

            // Asignar juegos a cada jugador
            Object.entries(currentMatchData.groups).forEach(([groupId, group]) => {
                const players = Object.values(group.players || {});
                players.forEach((player, index) => {
                    let assignedGameId;
                    if (matchConfig.match_type === 'individual') {
                        // Todos juegan el mismo juego
                        assignedGameId = templates[0];
                    } else {
                        // Cada jugador del grupo juega un juego diferente
                        assignedGameId = templates[index % templates.length];
                    }
                    updates[`matches/${currentMatchId}/groups/${groupId}/players/${player.key}/assigned_game`] = assignedGameId;
                });
            });

            // Finalmente, cambiar el estado de la partida para que todos sean redirigidos
            updates[`matches/${currentMatchId}/status`] = 'IN_PROGRESS';
            
            update(ref(db), updates)
                .then(() => {
                    console.log("Partida iniciada para todos los grupos.");
                })
                .catch(error => {
                    Swal.fire('Error', 'No se pudo iniciar el juego.', 'error');
                });
        }
        
        /**
         * NUEVO: Asigna roles a los jugadores de un grupo para "La Merca".
         */
        async function assignRolesToGroup(matchId, groupId) {
            const group = currentMatchData.groups[groupId];
            if (!group || !group.players) return;

            const players = Object.values(group.players);
            const roles = ['tariffs_specialist', 'compliance_officer', 'valuation_expert', 'logistics_coordinator', 'import_manager'];
            
            const updates = {};
            players.forEach((player, index) => {
                const roleId = roles[index % roles.length]; // Asigna roles en orden, ciclando si hay más jugadores que roles
                updates[`matches/${matchId}/groups/${groupId}/players/${player.key}/role`] = roleId;
            });

            await update(ref(db), updates);
            console.log(`Roles asignados para el grupo ${groupId}`);
        }

        // ----------------------------------------------------------------------
        // 🛠️ FUNCIONES DE UNIÓN Y CREACIÓN DE SALA (Implementación Completa)
        // ----------------------------------------------------------------------

        /**
         * ✅ MODIFICADO: Gestiona la unión de un jugador a un grupo con confirmación.
         */
        async function addPlayerToGroup(groupId) {
            playSound('soundClick');
            const group = currentMatchData.groups[groupId];
            const isFull = Object.keys(group.players || {}).length >= currentMatchData.config.players_per_group;

            if (isFull) {
                Swal.fire('Grupo Lleno', 'Este grupo ya ha alcanzado su capacidad máxima.', 'warning');
                return;
            }

            const playerGroupEntry = Object.entries(currentMatchData.groups || {}).find(([gId, g]) => g.players && g.players[currentPlayerKey]);
            const isInAGroup = !!playerGroupEntry;

            const result = await Swal.fire({
                title: isInAGroup ? `¿Cambiar al ${group.name}?` : `¿Unirte al ${group.name}?`,
                text: isInAGroup ? 'Se te moverá de tu grupo actual a este nuevo grupo.' : 'Confirmas tu participación en este grupo.',
                icon: 'question',
                showCancelButton: true,
                confirmButtonText: 'Sí, ¡unirme!',
                cancelButtonText: 'Cancelar',
                confirmButtonColor: '#2563eb',
                cancelButtonColor: '#6b7280'
            });

            if (!result.isConfirmed) return;

            // Primero, quitar al jugador de cualquier otro grupo en esta partida
            if (isInAGroup) {
                const oldGroupId = playerGroupEntry[0];
                await remove(ref(db, `matches/${currentMatchId}/groups/${oldGroupId}/players/${currentPlayerKey}`));
            }

            // Luego, añadirlo al nuevo grupo
            const playerRef = ref(db, `matches/${currentMatchId}/groups/${groupId}/players/${currentPlayerKey}`);
            await set(playerRef, {
                key: currentPlayerKey,
                name: playerName,
                ready: false
            });
        }

        /**
         * 🔑 Finaliza la unión a la partida.
         */
        async function joinMatchLobby(matchId, leaderKey = null) {
            currentMatchId = matchId;
            isRoomLeader = leaderKey === currentPlayerKey;

            document.getElementById('lobby-controls').classList.add('hidden');
            document.getElementById('match-lobby').classList.remove('hidden');
            document.getElementById('main-title').textContent = "Lobby de la Partida";

            // OPTIMIZACIÓN: Guardar la partida activa en el perfil del usuario.
            const userActiveMatchRef = ref(db, `usuarios/${currentPlayerKey}/activeMatch`);
            await set(userActiveMatchRef, matchId);

            startListening(matchId);
        }
        
        /**
         * ➕ Crea una sala y une al líder.
         */
        async function createMatch() {
            playSound('soundClick');
            // REFACTORIZADO: Lógica de creación de partida
            const matchType = document.querySelector('input[name="matchType"]:checked').value;
            const selectedTemplates = Array.from(document.querySelectorAll('.template-card.selected')).map(card => card.dataset.value);

            if (selectedTemplates.length === 0) {
                Swal.fire('Error', 'Debes seleccionar al menos una plantilla de juego.', 'warning');
                return;
            }

            let numGroups = parseInt(document.getElementById('numGroups').value);
            let playersPerGroup = parseInt(document.getElementById('playersPerGroup').value);

            if (matchType === 'grupal' && selectedTemplates.length !== playersPerGroup) {
                Swal.fire('Configuración Incompleta', `Para el modo grupal, debes seleccionar exactamente ${playersPerGroup} plantillas de juego (una por integrante). Has seleccionado ${selectedTemplates.length}.`, 'warning');
                return;
            }
            if (matchType === 'individual' && selectedTemplates.length > 1) {
                Swal.fire('Configuración Incorrecta', 'Para el modo individual, solo puedes seleccionar una plantilla de juego.', 'warning');
                return;
            }

            const newMatchId = 'PART-' + Math.random().toString(36).substring(2, 6).toUpperCase();

            if (matchType === 'individual') {
                numGroups = 1;
                playersPerGroup = 25;
            } else if (numGroups * playersPerGroup > 25) {
                Swal.fire('Límite Excedido', 'El número total de jugadores (grupos x jugadores por grupo) no puede superar 25.', 'error');
                return;
            }

            const matchConfig = {
                id: newMatchId,
                name: document.getElementById('matchName').value || `Partida de ${playerName}`,
                game_templates: selectedTemplates, // MODIFICADO: Guardamos un array de plantillas
                match_type: matchType,
                num_groups: numGroups,
                players_per_group: playersPerGroup,
            };

            const groupNames = ["Alfa", "Bravo", "Charlie", "Delta", "Echo"];
            const groups = {};
            for (let i = 0; i < matchConfig.num_groups; i++) {
                groups[`group_${i+1}`] = { id: `group_${i+1}`, name: `Grupo ${groupNames[i]}` };
            }
            
            await set(ref(db, `matches/${newMatchId}`), {
                id: newMatchId,
                status: 'WAITING',
                leader_key: currentPlayerKey,
                config: matchConfig,
                groups: groups
            });
            
            await joinMatchLobby(newMatchId, currentPlayerKey);
        }

        /**
         * 🔎 Intenta unirse a una sala existente.
         */
        async function joinMatchFromInput(idFromUrl = null, groupIdToJoin = null) {
            playSound('soundClick');
            const inputId = idFromUrl || document.getElementById('matchIdInput').value.trim().toUpperCase();
            if (!inputId) {
                 Swal.fire('Error', 'Ingresa el ID de la sala.', 'error');
                 return;
            }
            
            const snapshot = await get(ref(db, `matches/${inputId}`));
            if (snapshot.exists()) {
                 const matchData = snapshot.val();

                 // Validaciones
                 if (matchData.status === 'IN_PROGRESS') {
                      Swal.fire('Error', 'La partida ya está en curso.', 'error');
                      return;
                 }

                // NUEVO: Verificar si la sala está llena
                const totalPlayers = Object.values(matchData.groups || {}).reduce((sum, group) => sum + Object.keys(group.players || {}).length, 0);
                const maxCapacity = matchData.config.num_groups * matchData.config.players_per_group;
                
                // Solo verificar si el jugador no está ya en la partida
                const alreadyInMatch = Object.values(matchData.groups || {}).some(g => g.players && g.players[currentPlayerKey]);

                if (totalPlayers >= maxCapacity && !alreadyInMatch) {
                    Swal.fire('Sala Llena', 'Esta partida ha alcanzado su capacidad máxima de jugadores.', 'warning');
                    return;
                }

                await joinMatchLobby(inputId, matchData.leader_key);

                // NUEVO: Si se une por invitación a un grupo específico
                if (groupIdToJoin) {
                    // Pequeña espera para que el listener se active
                    setTimeout(() => addPlayerToGroup(groupIdToJoin), 500);
                }
            } else {
                 Swal.fire('Error', 'ID de sala no encontrado.', 'error');
            }
        }

        // ----------------------------------------------------------------------
        // 🔔 NUEVO: LÓGICA DE INVITACIONES
        // ----------------------------------------------------------------------

        async function openInviteModal() {
            playSound('soundClick');
            document.getElementById('inviteModal').classList.remove('hidden');
            const userListContainer = document.getElementById('userListContainer');
            userListContainer.innerHTML = '<p class="text-center text-gray-500">Cargando usuarios...</p>';

            // 1. Obtener todos los jugadores que ya están en esta partida
            const playersInThisMatch = new Set();
            if (currentMatchData.groups) {
                Object.values(currentMatchData.groups).forEach(group => {
                    if (group.players) {
                        Object.keys(group.players).forEach(pKey => playersInThisMatch.add(pKey));
                    }
                });
            }

            // 2. Obtener todos los usuarios (usar caché si ya se cargaron)
            let usersSnapshot; // CORRECCIÓN: Declarar la variable fuera del if.
            if (Object.keys(allUsers).length === 0) {
                usersSnapshot = await get(ref(db, 'usuarios'));
                if (usersSnapshot.exists()) allUsers = usersSnapshot.val();
            }
            
            if (Object.keys(allUsers).length > 0) { // CORRECCIÓN: Usar el objeto `allUsers` que ya está poblado.
                const users = allUsers;
                let html = '';
                Object.keys(users).forEach(key => {
                    // MODIFICADO: No mostrar al jugador actual en la lista de invitables
                    if (key === currentPlayerKey) return;

                    const user = users[key];
                    const isInThisMatch = playersInThisMatch.has(key);
                    const score = user.puntaje || 0;

                    const buttonHtml = isInThisMatch
                        ? `<span class="text-xs bg-gray-400 text-white font-semibold px-3 py-1 rounded-md cursor-not-allowed">En Partida</span>`
                        : `<button onclick="sendInvitation('${key}', '${user.nombre}')" class="text-xs bg-blue-500 text-white font-semibold px-3 py-1 rounded-md hover:bg-blue-600">Invitar</button>`;

                    html += `
                        <div class="user-item p-2 border rounded-lg flex justify-between items-center hover:bg-gray-100" data-name="${user.nombre.toLowerCase()}">

                            <div>
                                <span class="font-semibold">${user.nombre}</span>
                                <span class="text-xs text-gray-500 ml-2">🏆 ${score} pts</span>
                            </div>
                            ${buttonHtml}
                        </div>
                    `;
                });
                userListContainer.innerHTML = html;
            } else {
                userListContainer.innerHTML = '<p class="text-center text-gray-500">No se encontraron usuarios.</p>';
            }
        }

        function closeInviteModal() {
            playSound('soundClick');
            document.getElementById('inviteModal').classList.add('hidden');
        }


        function filterUserList() {
            const filter = document.getElementById('userSearchInput').value.toLowerCase();
            const items = document.querySelectorAll('.user-item');
            items.forEach(item => {
                const name = item.dataset.name;
                item.style.display = name.includes(filter) ? '' : 'none';
            });
        }

        async function sendInvitation(targetPlayerKey, targetPlayerName) {
            playSound('soundClick');
            if (!currentMatchId) {
                Swal.fire('Error', 'Debes estar en una sala para poder invitar.', 'error');
                return;
            }

            // NUEVO: Encontrar el grupo del anfitrión para incluirlo en la invitación
            const hostGroupEntry = Object.entries(currentMatchData.groups || {}).find(([gId, g]) => g.players && g.players[currentPlayerKey]);
            if (!hostGroupEntry) {
                Swal.fire('Error', 'Debes estar en un grupo para poder invitar a él.', 'warning');
                return;
            }
            const hostGroupId = hostGroupEntry[0];

            const notification = {
                tipo: 'INVITACION_SALA',
                remitente_nombre: playerName,
                remitente_key: currentPlayerKey,
                id_sala: currentMatchId,
                id_grupo: hostGroupId, // <-- AÑADIDO: El ID del grupo del anfitrión
                fecha: Date.now(), // Usar ServerValue.TIMESTAMP si se prefiere la hora del servidor
                leido: false
            };

            const notificationsRef = ref(db, `usuarios/${targetPlayerKey}/notificaciones`);
            const newNotifRef = push(notificationsRef); // Genera una clave única para la notificación

            try {
                await set(newNotifRef, notification);
                Swal.fire({
                    toast: true, position: 'top-end',
                    icon: 'success', title: `¡Invitación enviada a ${targetPlayerName}!`,
                    showConfirmButton: false, timer: 2000
                });
            } catch (error) {
                Swal.fire('Error', 'No se pudo enviar la invitación.', 'error');
                console.error("Error al enviar invitación:", error);
            }
        }

        window.openInviteModal = openInviteModal;
        window.closeInviteModal = closeInviteModal;
        window.filterUserList = filterUserList;
        window.sendInvitation = sendInvitation;

        /**
         * 👑 NUEVO: Lógica para pasar el liderazgo.
         */
        function openPassLeaderModal() {
            playSound('soundClick');
            const modal = document.getElementById('passLeaderModal');
            const container = document.getElementById('newLeaderListContainer');
            container.innerHTML = '';

            const allPlayersInMatch = Object.values(currentMatchData.groups || {}).flatMap(g => Object.values(g.players || {}));
            const otherPlayers = allPlayersInMatch.filter(p => p.key !== currentPlayerKey);

            if (otherPlayers.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500">No hay otros jugadores a quienes pasar el liderazgo.</p>';
            } else {
                otherPlayers.forEach(player => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'p-3 border rounded-lg flex justify-between items-center cursor-pointer leader-option';
                    playerDiv.innerHTML = `
                        <span class="font-semibold">${player.name}</span>
                        <span class="text-xs text-gray-500">Jugador en sala</span>
                    `;
                    playerDiv.onclick = () => passLeadershipTo(player.key);
                    container.appendChild(playerDiv);
                });
            }
            modal.classList.remove('hidden');
        }

        function closePassLeaderModal() {
            document.getElementById('passLeaderModal').classList.add('hidden');
        }

        async function passLeadershipTo(newLeaderKey) {
            playSound('soundClick');
            closePassLeaderModal();

            Swal.fire({
                title: 'Transfiriendo Liderazgo...',
                allowOutsideClick: false,
                didOpen: () => Swal.showLoading()
            });

            if (currentMatchId) {
                const matchRef = ref(db, `matches/${currentMatchId}`);
                await update(matchRef, { leader_key: newLeaderKey });
                // El antiguo líder ahora es un jugador normal.
                isRoomLeader = false;
                // No lo sacamos, solo actualizamos la UI. El listener se encargará.
                Swal.close();
            }
        }

        window.openPassLeaderModal = openPassLeaderModal;
        window.closePassLeaderModal = closePassLeaderModal;
        window.passLeadershipTo = passLeadershipTo;

        /**
         * NUEVA FUNCIÓN: Al cargar la página, busca si el jugador ya está en una sala.
         */
        async function checkForExistingMatchAndJoin() {
            try {
                // OPTIMIZACIÓN: Leer directamente del perfil del usuario.
                const userRef = ref(db, `usuarios/${currentPlayerKey}`);
                const userSnapshot = await get(userRef);

                if (userSnapshot.exists()) {
                    const userData = userSnapshot.val();
                    const activeMatchId = userData.activeMatch;

                    if (activeMatchId) {
                        // Si tiene una partida activa, intenta unirse.
                        const matchSnapshot = await get(ref(db, `matches/${activeMatchId}`));
                        if (matchSnapshot.exists()) {
                            await joinMatchLobby(activeMatchId, matchSnapshot.val().leader_key);
                        }
                    }
                }
            } catch (error) {
                Swal.fire('Error', 'No se pudo verificar tu estado en las salas. Por favor, intenta unirte manualmente.', 'error');
            }
        }

        /**
         * NUEVA FUNCIÓN: Maneja el parámetro de URL para unirse a una sala.
         */
        async function handleJoinFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const matchIdToJoin = urlParams.get('joinRoomId');
            const groupIdToJoin = urlParams.get('groupId'); // NUEVO: Leer el ID del grupo

            if (matchIdToJoin) {
                await joinMatchFromInput(matchIdToJoin.toUpperCase(), groupIdToJoin);
            } else {
                // Si no hay invitación, buscar si ya estaba en una sala
                await checkForExistingMatchAndJoin();
            }
        }

        /**
         * NUEVO: Copia el enlace de invitación al portapapeles.
         */
        function copyInviteLink() {
            const url = `${window.location.origin}${window.location.pathname}?joinRoomId=${currentMatchId}`;
            navigator.clipboard.writeText(url).then(() => {
                Swal.fire({
                    toast: true, position: 'top-end',
                    icon: 'success', title: '¡Enlace de invitación copiado!',
                    showConfirmButton: false, timer: 2000
                });
            });
        }

        window.copyInviteLink = copyInviteLink;

        // ----------------------------------------------------------------------
        // 🚀 INICIALIZACIÓN
        // ----------------------------------------------------------------------
        
        /**
         * NUEVO: Verifica si el usuario tiene permiso para estar en esta página.
         * Si no, lo redirige al index.
         */
        async function verifyAccess() {
            const playerKey = localStorage.getItem('aduweb_player_key'); // Reutilizamos la variable global
            if (!playerKey) {
                Swal.fire({
                    title: 'Acceso Denegado',
                    text: 'Debes iniciar sesión para acceder a las partidas en línea.',
                    icon: 'error',
                    confirmButtonText: 'Ir al Login'
                }).then(() => window.location.href = 'index.html');
                return false;
            }

            const userRef = ref(db, `usuarios/${playerKey}`);
            const snapshot = await get(userRef);

            if (!snapshot.exists()) {
                Swal.fire('Error', 'No se pudo encontrar tu perfil de usuario.', 'error').then(() => window.location.href = 'index.html');
                return false;
            }

            const userData = snapshot.val();
            const ticket = userData.tickets?.online_match_ticket;
            const hasActiveTicket = ticket && ticket.expiresAt > Date.now();

            if (hasActiveTicket) {
                return true; // Acceso permitido
            } else {
                Swal.fire({
                    title: 'Acceso Bloqueado',
                    text: 'Necesitas un "Tiquete: Partidas en Línea" activo para entrar. Cómpralo en la tienda usando tus puntos EXP.',
                    icon: 'warning',
                    confirmButtonText: 'Volver al Inicio'
                }).then(() => {
                    window.location.href = 'index.html';
                    // OPTIMIZACIÓN: Si se le niega el acceso, limpiamos el estado por si acaso.
                    const userActiveMatchRef = ref(db, `usuarios/${playerKey}/activeMatch`);
                    set(userActiveMatchRef, null);

                });
                return false; // Acceso denegado
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            // 1. Verificar acceso ANTES de hacer cualquier otra cosa.
            // Ocultar el contenido principal por defecto para evitar un "parpadeo"
            document.querySelector('main').style.visibility = 'hidden';
            const hasAccess = await verifyAccess();
            if (!hasAccess) {
                // Si no hay acceso, no se hace nada más. El Swal se encarga de la redirección.
                return;
            }

            // Si hay acceso, mostrar el contenido y continuar con la lógica del lobby.
            document.querySelector('main').style.visibility = 'visible';

            // 2. Si el acceso es válido, continuar con la inicialización normal.
            currentPlayerKey = localStorage.getItem('aduweb_player_key'); 
            playerName = localStorage.getItem('aduweb_player_name'); 

            // Lógica de inicialización
            handleJoinFromUrl();
            renderAllTemplates(); // Renderizar todas las plantillas
            loadFeaturedTemplates(); // Cargar las plantillas destacadas

            // Exportar funciones al scope global para que funcionen con onclick
            window.createMatch = createMatch;
            window.joinMatchFromInput = joinMatchFromInput;
            window.joinGroup = addPlayerToGroup; // Renombrado para claridad
            window.startMatch = startMatch;
            window.leaveMatch = leaveMatch;
            window.setPlayerReady = setPlayerReady;
            window.playSound = playSound;

            // --- Lógica de Selección de Plantillas ---
            const container = document.getElementById('template-selection-container');
            let selectionOrder = []; // Array para mantener el orden de selección
            const templateCards = document.querySelectorAll('.template-card');
            templateCards.forEach(card => {
                card.addEventListener('click', () => {
                    const isIndividual = document.querySelector('input[name="matchType"]:checked').value === 'individual';
                    if (isIndividual) {
                        // Deseleccionar todas y seleccionar solo la actual
                        templateCards.forEach(c => c.classList.remove('selected'));
                        card.classList.toggle('selected'); // Permite deseleccionar también
                        selectionOrder = card.classList.contains('selected') ? [card.dataset.value] : [];
                    } else {
                        // Lógica para modo grupal con orden
                        const cardValue = card.dataset.value;
                        const indexInOrder = selectionOrder.indexOf(cardValue);

                        if (indexInOrder > -1) {
                            // Si ya está seleccionado, se deselecciona
                            selectionOrder.splice(indexInOrder, 1);
                            card.classList.remove('selected');
                        } else {
                            // Si no está seleccionado, se añade
                            selectionOrder.push(cardValue);
                            card.classList.add('selected');
                        }
                    }
                    updateSelectionNumbers();
                });
            });

            function updateSelectionNumbers() {
                templateCards.forEach(card => {
                    const badge = card.querySelector('.selection-badge');
                    const index = selectionOrder.indexOf(card.dataset.value);
                    badge.textContent = index > -1 ? index + 1 : '';
                });
            }

            const matchTypeRadios = document.querySelectorAll('input[name="matchType"]');
            matchTypeRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    // Al cambiar de modo, limpiar la selección
                    templateCards.forEach(c => c.classList.remove('selected'));
                    selectionOrder = [];
                    updateSelectionNumbers();
                });
            });
        });

        function renderAllTemplates() {
            const container = document.getElementById('template-selection-container');
            container.innerHTML = ''; // Limpiar por si acaso

            TEMPLATE_DATA.forEach(template => {
                const card = document.createElement('div');
                card.className = `template-card`;
                card.dataset.value = template.id;
                card.innerHTML = `
                    <div class="selection-badge"></div>
                    <div class="template-icon text-gray-400 w-12 h-12 mx-auto flex items-center justify-center mb-2 transition-colors">${template.icon}</div>
                    <h4 class="template-name font-bold text-sm text-gray-700 transition-colors">${template.name}</h4>
                `;
                container.appendChild(card);
            });
        }


        // NUEVO: Función para mostrar/ocultar opciones de grupo
        function toggleGroupOptions() {
            const matchType = document.querySelector('input[name="matchType"]:checked').value;
            const groupOptions = document.getElementById('group-options');
            if (matchType === 'individual') {
                groupOptions.classList.add('hidden');
            } else {
                groupOptions.classList.remove('hidden');
            }
        }
        window.toggleGroupOptions = toggleGroupOptions;
    </script>
</body>

    <script type="module">
        import { getDatabase, ref, get } from "https://www.gstatic.com/firebasejs/9.6.11/firebase-database.js";
        import { firebaseConfig } from "./config.js";
        const db = getDatabase(initializeApp(firebaseConfig));

        // --- NUEVA FUNCIÓN: Cargar Plantillas Destacadas ---
        async function loadFeaturedTemplates() {
            const container = document.getElementById('featured-templates-container');
            if (!container) return;
            container.innerHTML = '<p class="text-gray-500 col-span-full text-center">Calculando plantillas mejor calificadas...</p>';

            try {
                const ratingsRef = ref(db, 'game_ratings');
                const snapshot = await get(ratingsRef);

                if (!snapshot.exists()) {
                    container.innerHTML = '<p class="text-gray-500 col-span-full text-center">Aún no hay calificaciones para mostrar.</p>';
                    return;
                }

                const ratings = snapshot.val();
                const templateStats = {};

                // Calcular promedio de calificación para cada plantilla
                Object.keys(ratings).forEach(templateId => {
                    const templateRatings = Object.values(ratings[templateId]);
                    const totalScore = templateRatings.reduce((sum, r) => sum + r.rating, 0);
                    const average = totalScore / templateRatings.length;
                    templateStats[templateId] = { average, count: templateRatings.length };
                });

                // Ordenar por calificación y obtener las 3 mejores
                const topTemplates = Object.keys(templateStats)
                    .sort((a, b) => templateStats[b].average - templateStats[a].average)
                    .slice(0, 3);

                let html = '';
                topTemplates.forEach(templateId => {
                    const templateInfo = TEMPLATE_DATA.find(t => t.id === templateId);
                    if (templateInfo) {
                        // MODIFICADO: Ahora es un botón que llama a una función
                        html += `
                            <button onclick="createMatchFromTemplate('${templateInfo.id}')" class="bg-white p-4 rounded-xl border-2 border-gray-200 text-center transition-all duration-200 hover:shadow-lg hover:border-blue-500 hover:-translate-y-1">
                                <div class="text-4xl mx-auto mb-2">${templateInfo.icon}</div>
                                <h4 class="font-bold text-gray-800">${templateInfo.name}</h4>
                                <p class="text-sm text-yellow-600 font-bold">⭐ ${templateStats[templateId].average.toFixed(1)} / 5.0</p>
                            </button>
                        `;
                    }
                });

                container.innerHTML = html || '<p class="text-gray-500 col-span-full text-center">No se pudieron cargar las plantillas destacadas.</p>';

            } catch (error) {
                console.error("Error al cargar plantillas destacadas:", error);
                container.innerHTML = '<p class="text-red-500 col-span-full text-center">Error al cargar datos.</p>';
            }
        }
        window.loadFeaturedTemplates = loadFeaturedTemplates; // Exponer la función globalmente
    </script>
</html>
